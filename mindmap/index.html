<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>MindCanvas - Simple MindMap (Cloud)</title>
    
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        .noselect {
            -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none;
            -moz-user-select: none; -ms-user-select: none; user-select: none;
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-800 overflow-hidden">
    <div id="root"></div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.7.1/firebase-app.js";
        import { getDatabase, ref, set, onValue } from "https://www.gstatic.com/firebasejs/11.7.1/firebase-database.js";
        import { getAuth, signInWithPopup, GoogleAuthProvider, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.7.1/firebase-auth.js";

        const firebaseConfig = {
            apiKey: "AIzaSyAd08tVXgWZ2_dg3jzvhawmH4jtolRmfhY",
            authDomain: "itnews-82b60.firebaseapp.com",
            databaseURL: "https://itnews-82b60-default-rtdb.firebaseio.com",
            projectId: "itnews-82b60",
            storageBucket: "itnews-82b60.firebasestorage.app",
            messagingSenderId: "719267588761",
            appId: "1:719267588761:web:3c4607cb799620f9446608"
        };

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
        const auth = getAuth(app);
        const ALLOWED_EMAIL = "eundang@gmail.com";

        window.SBL_MindMap = {
            login: () => signInWithPopup(auth, new GoogleAuthProvider()),
            
            save: (nodes) => {
                const user = auth.currentUser;
                if (user && user.email === ALLOWED_EMAIL) {
                    return set(ref(db, `users/${user.uid}/mindmap`), nodes);
                }
                return Promise.resolve();
            },

            init: (onLoad, onAuthUpdate) => {
                onAuthStateChanged(auth, (user) => {
                    if (user && user.email === ALLOWED_EMAIL) {
                        onAuthUpdate(user);
                        // ë°ì´í„° ë¡œë“œ ë¦¬ìŠ¤ë„ˆ
                        onValue(ref(db, `users/${user.uid}/mindmap`), (snapshot) => {
                            const data = snapshot.val();
                            // [ìˆ˜ì • í•µì‹¬] ë°ì´í„°ê°€ ì—†ì–´ë„(null) ë¡œë“œ ì™„ë£Œ ì‹ í˜¸ë¥¼ ë³´ëƒ„
                            onLoad(data || null);
                        });
                    } else {
                        onAuthUpdate(null);
                        if (user) alert("ê¶Œí•œì´ ì—†ëŠ” ê³„ì •ì…ë‹ˆë‹¤.");
                    }
                });
            }
        };
    </script>

    <script type="text/babel">
        const { useState, useRef, useEffect, useLayoutEffect } = React;

        // --- Icons ---
        const IconBase = ({ children, size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>{children}</svg>
        );
        const Plus = (props) => <IconBase {...props}><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></IconBase>;
        const Minus = (props) => <IconBase {...props}><line x1="5" y1="12" x2="19" y2="12"></line></IconBase>;
        const Download = (props) => <IconBase {...props}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></IconBase>;
        const Upload = (props) => <IconBase {...props}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></IconBase>;
        const Trash2 = (props) => <IconBase {...props}><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></IconBase>;
        const Layout = (props) => <IconBase {...props}><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="9" y1="21" x2="9" y2="9"></line></IconBase>;
        const AlignCenter = (props) => <IconBase {...props}><line x1="18" y1="10" x2="6" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="18" y1="18" x2="6" y2="18"></line></IconBase>;
        const Copy = (props) => <IconBase {...props}><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></IconBase>;
        const Scissors = (props) => <IconBase {...props}><circle cx="6" cy="6" r="3"></circle><circle cx="6" cy="18" r="3"></circle><line x1="20" y1="4" x2="8.12" y2="15.88"></line><line x1="14.47" y1="14.48" x2="20" y2="20"></line><line x1="8.12" y1="8.12" x2="12" y2="12"></line></IconBase>;
        const Clipboard = (props) => <IconBase {...props}><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></IconBase>;
        const Home = (props) => <IconBase {...props}><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline></IconBase>;
        const Save = (props) => <IconBase {...props}><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></IconBase>;

        const INITIAL_NODES = [
            { id: 'root', text: 'ì¤‘ì‹¬ í† í”½', x: 0, y: 0, width: 160, height: 60, parentId: null, color: '#3b82f6' },
            { id: '1', text: 'ì•„ì´ë””ì–´ 1', x: 0, y: -150, width: 140, height: 50, parentId: 'root', color: '#10b981' },
            { id: '2', text: 'ì•„ì´ë””ì–´ 2', x: 200, y: 100, width: 140, height: 50, parentId: 'root', color: '#f59e0b' },
            { id: '3', text: 'ì•„ì´ë””ì–´ 3', x: -200, y: 100, width: 140, height: 50, parentId: 'root', color: '#ef4444' },
        ];

        function App() {
            const [nodes, setNodes] = useState(INITIAL_NODES);
            const [scale, setScale] = useState(1);
            const [offset, setOffset] = useState({ x: window.innerWidth / 2, y: window.innerHeight / 2 });
            const [selectedId, setSelectedId] = useState(null);
            const [isDragging, setIsDragging] = useState(false);
            const [isPanning, setIsPanning] = useState(false);
            const [isResizing, setIsResizing] = useState(false);
            const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
            const [dragSnapshot, setDragSnapshot] = useState(null);
            const [initialOffset, setInitialOffset] = useState({ x: 0, y: 0 });
            const [editingId, setEditingId] = useState(null);
            const [clipboard, setClipboard] = useState(null); 
            const [pinchDist, setPinchDist] = useState(null);
            
            // ì €ì¥ ìƒíƒœ ê´€ë¦¬
            const [user, setUser] = useState(null);
            const [isLoaded, setIsLoaded] = useState(false); // ë°ì´í„° ë¡œë“œ ì™„ë£Œ ì—¬ë¶€
            const [saveStatus, setSaveStatus] = useState('idle'); // idle, saving, saved, error

            const containerRef = useRef(null);
            const fileInputRef = useRef(null);
            const saveTimeoutRef = useRef(null);

            // --- Firebase ì—°ë™ ---
            useEffect(() => {
                const checkFirebase = () => {
                    if (window.SBL_MindMap) {
                        window.SBL_MindMap.init(
                            (data) => {
                                // ë°ì´í„°ê°€ ìˆìœ¼ë©´ ë®ì–´ì”Œìš°ê³ , ì—†ìœ¼ë©´ ì´ˆê¸°ê°’ ìœ ì§€ (í•˜ì§€ë§Œ ë¡œë“œ ì™„ë£Œë¡œ í‘œì‹œ)
                                if (data) {
                                    setNodes(data);
                                }
                                setIsLoaded(true); // [ì¤‘ìš”] ë¡œë“œ ì™„ë£Œ í”Œë˜ê·¸
                            },
                            (userInfo) => {
                                setUser(userInfo);
                            }
                        );
                    } else {
                        setTimeout(checkFirebase, 100);
                    }
                };
                checkFirebase();
            }, []);

            // --- ìë™ ì €ì¥ ë¡œì§ (ë¡œë“œ ì™„ë£Œëœ ì´í›„ì—ë§Œ ì‘ë™) ---
            useEffect(() => {
                if (!isLoaded || !user) return; // ë¡œë”© ì „ì—ëŠ” ì €ì¥ ê¸ˆì§€ (ì´ˆê¸°í™” ë°©ì§€)

                setSaveStatus('saving');
                if (saveTimeoutRef.current) clearTimeout(saveTimeoutRef.current);
                
                saveTimeoutRef.current = setTimeout(() => {
                    if (window.SBL_MindMap) {
                        window.SBL_MindMap.save(nodes).then(() => {
                            setSaveStatus('saved');
                            setTimeout(() => setSaveStatus('idle'), 2000);
                        });
                    }
                }, 1000); // 1ì´ˆ ë””ë°”ìš´ìŠ¤

                return () => clearTimeout(saveTimeoutRef.current);
            }, [nodes, isLoaded, user]);

            // --- ìœ í‹¸ë¦¬í‹° (ê¸°ì¡´ ìœ ì§€) ---
            const screenToWorld = (sx, sy) => ({ x: (sx - offset.x) / scale, y: (sy - offset.y) / scale });
            const generateId = () => Math.random().toString(36).substr(2, 9);
            const getSubtreeMaxY = (nodeId) => {
                let maxY = -Infinity;
                const traverse = (id) => { const node = nodes.find(n => n.id === id); if(!node) return; const bottom = node.y + node.height; if(bottom > maxY) maxY = bottom; nodes.filter(n => n.parentId === id).forEach(c => traverse(c.id)); };
                traverse(nodeId); return maxY === -Infinity ? null : maxY;
            };

            useLayoutEffect(() => {
                const newNodes = nodes.map(node => {
                    const el = document.getElementById(`node-${node.id}`);
                    if (el && Math.abs(el.offsetHeight - node.height) > 0) return { ...node, height: el.offsetHeight };
                    return node;
                });
                if (newNodes.some((n, i) => n.height !== nodes[i].height)) setNodes(newNodes);
            }, [nodes]); 

            const autoLayout = () => {
                const root = nodes.find(n => !n.parentId); if (!root) return;
                const newNodes = [...nodes];
                const getChildren = (id) => nodes.filter(n => n.parentId === id);
                const calculateSubtreeHeight = (nodeId) => { const children = getChildren(nodeId); if (children.length === 0) return 60; return children.reduce((sum, child) => sum + calculateSubtreeHeight(child.id), 0); };
                const layoutNode = (nodeId, x, y, direction) => { 
                    const children = getChildren(nodeId); let currentY = y - (calculateSubtreeHeight(nodeId) / 2);
                    children.forEach(child => { const h = calculateSubtreeHeight(child.id); const childY = currentY + (h / 2); const idx = newNodes.findIndex(n => n.id === child.id); if (idx !== -1) { newNodes[idx] = { ...newNodes[idx], x: x + (direction * 200), y: childY }; layoutNode(child.id, x + (direction * 200), childY, direction); } currentY += h; });
                };
                const rootIndex = newNodes.findIndex(n => n.id === root.id); newNodes[rootIndex] = { ...newNodes[rootIndex], x: 0, y: 0 };
                const rootChildren = getChildren(root.id); const left = [], right = []; rootChildren.forEach((c, i) => (i % 2 === 0 ? right : left).push(c));
                let ly = -(left.reduce((s, c) => s + calculateSubtreeHeight(c.id), 0) / 2); left.forEach(c => { const h = calculateSubtreeHeight(c.id); const cy = ly + (h/2); const idx = newNodes.findIndex(n => n.id === c.id); newNodes[idx] = { ...newNodes[idx], x: -250, y: cy }; layoutNode(c.id, -250, cy, -1); ly += h; });
                let ry = -(right.reduce((s, c) => s + calculateSubtreeHeight(c.id), 0) / 2); right.forEach(c => { const h = calculateSubtreeHeight(c.id); const cy = ry + (h/2); const idx = newNodes.findIndex(n => n.id === c.id); newNodes[idx] = { ...newNodes[idx], x: 250, y: cy }; layoutNode(c.id, 250, cy, 1); ry += h; });
                setNodes(newNodes); setOffset({ x: window.innerWidth / 2, y: window.innerHeight / 2 });
            };

            const handleStart = (clientX, clientY, nodeId = null, type = 'drag', e) => {
                if (type === 'resize') { setIsResizing(true); setDragStart({ x: clientX, y: clientY }); return; }
                if (nodeId) {
                    const node = nodes.find(n => n.id === nodeId); setSelectedId(nodeId); setIsDragging(true); setDragStart({ x: clientX, y: clientY });
                    const snapshot = {}; const isSingle = e && (e.ctrlKey || e.metaKey);
                    if (isSingle) { snapshot[nodeId] = { x: node.x, y: node.y }; }
                    else { const traverse = (id) => { const n = nodes.find(x => x.id === id); if(n) { snapshot[id] = { x: n.x, y: n.y }; nodes.filter(c => c.parentId === id).forEach(c => traverse(c.id)); } }; traverse(nodeId); }
                    setDragSnapshot(snapshot);
                } else { setSelectedId(null); setIsPanning(true); setDragStart({ x: clientX, y: clientY }); setInitialOffset({ x: offset.x, y: offset.y }); }
            };

            const handleMove = (clientX, clientY) => {
                if (isDragging && selectedId && dragSnapshot) {
                    const dx = (clientX - dragStart.x) / scale; const dy = (clientY - dragStart.y) / scale;
                    setNodes(nodes.map(n => dragSnapshot[n.id] ? { ...n, x: dragSnapshot[n.id].x + dx, y: dragSnapshot[n.id].y + dy } : n));
                } else if (isResizing && selectedId) {
                    const node = nodes.find(n => n.id === selectedId); const dx = (clientX - dragStart.x) / scale;
                    setNodes(nodes.map(n => n.id === selectedId ? { ...n, width: Math.max(50, node.width + dx) } : n)); setDragStart({ x: clientX, y: clientY }); 
                } else if (isPanning) { setOffset({ x: initialOffset.x + clientX - dragStart.x, y: initialOffset.y + clientY - dragStart.y }); }
            };

            const handleEnd = () => { setIsDragging(false); setIsPanning(false); setIsResizing(false); setDragSnapshot(null); setPinchDist(null); };
            const onMouseDown = (e, nodeId, type) => { if (e.button !== 0) return; e.stopPropagation(); handleStart(e.clientX, e.clientY, nodeId, type, e); };
            const onMouseMove = (e) => { handleMove(e.clientX, e.clientY); };
            const handleWheel = (e) => {
                if (e.ctrlKey || e.metaKey) { e.preventDefault(); const newScale = Math.min(Math.max(0.1, scale - e.deltaY * 0.001), 5); const mw = screenToWorld(e.clientX, e.clientY); setScale(newScale); setOffset({ x: e.clientX - mw.x * newScale, y: e.clientY - mw.y * newScale }); }
                else { setOffset(prev => ({ x: prev.x - e.deltaX, y: prev.y - e.deltaY })); }
            };
            const onTouchStart = (e, nodeId, type) => {
                if (e.touches.length === 2) { setPinchDist(Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY)); setIsPanning(false); setIsDragging(false); }
                else if (e.touches.length === 1) handleStart(e.touches[0].clientX, e.touches[0].clientY, nodeId, type, e);
            };
            const onTouchMove = (e) => {
                if (e.touches.length === 2 && pinchDist !== null) { const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY); const newScale = Math.min(Math.max(0.1, scale * (dist / pinchDist)), 5); const cx = (e.touches[0].clientX + e.touches[1].clientX) / 2, cy = (e.touches[0].clientY + e.touches[1].clientY) / 2; const cw = screenToWorld(cx, cy); setScale(newScale); setOffset({ x: cx - cw.x * newScale, y: cy - cw.y * newScale }); setPinchDist(dist); }
                else if (e.touches.length === 1) handleMove(e.touches[0].clientX, e.touches[0].clientY);
            };

            const getSubtree = (rootId) => { const r = []; const t = (id) => { const n = nodes.find(x => x.id === id); if(n) { r.push(n); nodes.filter(c => c.parentId === id).forEach(c => t(c.id)); } }; t(rootId); return r; };
            const copyNode = () => { if (!selectedId) return; setClipboard({ rootId: selectedId, data: JSON.parse(JSON.stringify(getSubtree(selectedId))) }); };
            const cutNode = () => { if (!selectedId || selectedId === 'root') return; copyNode(); deleteNode(); };
            const pasteNode = () => {
                if (!clipboard || !selectedId) return; const { rootId, data } = clipboard; const target = nodes.find(n => n.id === selectedId); if (!target) return; const root = nodes.find(n => !n.parentId);
                let tDir = target.id !== root.id ? (target.x >= root.x ? 1 : -1) : 1; const cRoot = data.find(n => n.id === rootId); const des = data.filter(n => n.id !== rootId);
                let sDir = des.length > 0 ? ((des.reduce((s, n) => s + (n.x - cRoot.x), 0) / des.length) >= 0 ? 1 : -1) : tDir;
                const flip = tDir !== sDir; let sib = nodes.filter(n => n.parentId === selectedId); if (target.parentId === null) sib = sib.filter(n => (n.x < target.x ? -1 : 1) === tDir); sib.sort((a, b) => a.y - b.y);
                let ny = target.y; if (sib.length > 0) { const last = sib[sib.length - 1]; const max = getSubtreeMaxY(last.id); ny = (max !== null ? max : (last.y + last.height)) + 20; }
                const nx = target.x + (target.width + 50) * tDir; const idMap = {}; data.forEach(n => idMap[n.id] = generateId());
                const newNodes = data.map(n => { const isRoot = n.id === rootId; let rx = n.x - cRoot.x, ry = n.y - cRoot.y; if (flip) rx = -rx; return { ...n, id: idMap[n.id], parentId: isRoot ? selectedId : idMap[n.parentId], x: nx + rx, y: ny + ry }; });
                setNodes([...nodes, ...newNodes]);
            };

            const addNode = () => {
                if (!selectedId) return; const p = nodes.find(n => n.id === selectedId); if (!p) return; const nid = generateId(); const root = nodes.find(n => !n.parentId);
                let dir = p.parentId === null ? (Math.random() > 0.5 ? 1 : -1) : (p.x < root.x ? -1 : 1); let sib = nodes.filter(n => n.parentId === selectedId);
                if (p.parentId === null) sib = sib.filter(n => (n.x < p.x ? -1 : 1) === dir); let ny = p.y;
                if (sib.length > 0) { sib.sort((a, b) => a.y - b.y); const last = sib[sib.length - 1]; const max = getSubtreeMaxY(last.id); ny = (max !== null ? max : (last.y + last.height)) + 20; }
                setNodes([...nodes, { id: nid, text: '', x: p.x + (p.width + 50) * dir, y: ny, width: 120, height: 40, parentId: selectedId, color: '#64748b' }]); setSelectedId(nid); setTimeout(() => setEditingId(nid), 100);
            };
            const deleteNode = () => { if (!selectedId || selectedId === 'root') return; const dels = new Set([selectedId]); let c = true; while(c) { c = false; nodes.forEach(n => { if (n.parentId && dels.has(n.parentId) && !dels.has(n.id)) { dels.add(n.id); c = true; } }); } setNodes(nodes.filter(n => !dels.has(n.id))); setSelectedId(null); };
            const updateNodeText = (id, text) => setNodes(nodes.map(n => n.id === id ? { ...n, text } : n));
            const handleEditBlur = (id, text) => { setEditingId(null); if (!text || text.trim() === '') updateNodeText(id, 'ìƒˆë¡œìš´ í† í”½'); };
            const exportMap = () => { const d = JSON.stringify(nodes, null, 2); const b = new Blob([d], { type: 'application/json' }); const u = URL.createObjectURL(b); const a = document.createElement('a'); a.href = u; a.download = 'mindmap.json'; a.click(); URL.revokeObjectURL(u); };
            const importMap = (e) => {
                const f = e.target.files[0]; if (!f) return; const r = new FileReader();
                r.onload = (ev) => { try { const d = JSON.parse(ev.target.result); const n = d.nodes || d; if (n && n.length > 0) { setNodes(n); setOffset({ x: window.innerWidth / 2, y: window.innerHeight / 2 }); setScale(1); } else alert('ë°ì´í„° ì—†ìŒ'); } catch (err) { alert('ì˜¤ë¥˜'); } if (fileInputRef.current) fileInputRef.current.value = ''; };
                r.readAsText(f);
            };

            useEffect(() => { const h = (e) => { if (editingId) return; if (e.key === 'Tab') { e.preventDefault(); addNode(); } else if (e.key === 'Delete' || e.key === 'Backspace') deleteNode(); else if ((e.ctrlKey || e.metaKey) && e.key === 'c') copyNode(); else if ((e.ctrlKey || e.metaKey) && e.key === 'x') cutNode(); else if ((e.ctrlKey || e.metaKey) && e.key === 'v') pasteNode(); }; window.addEventListener('keydown', h); return () => window.removeEventListener('keydown', h); }, [selectedId, nodes, editingId, clipboard]);

            const renderConnections = () => nodes.map(n => { if (!n.parentId) return null; const p = nodes.find(x => x.id === n.parentId); if (!p) return null; const sx = p.x + (n.x > p.x ? p.width : 0), sy = p.y + p.height / 2, ex = n.x + (n.x > p.x ? 0 : n.width), ey = n.y + n.height / 2, c1x = sx + (ex - sx) / 2; return <path key={`e-${n.id}`} d={`M ${sx} ${sy} C ${c1x} ${sy}, ${c1x} ${ey}, ${ex} ${ey}`} stroke="#94a3b8" strokeWidth="2" fill="none" />; });

            return (
                <div className="w-full h-screen flex flex-col font-sans touch-none select-none">
                    <div className="h-14 bg-white border-b border-slate-200 flex items-center px-4 justify-between shadow-sm z-10 shrink-0">
                        <div className="flex items-center space-x-2">
                            <div className="bg-indigo-600 p-1.5 rounded-lg text-white mr-2"><Layout size={20} /></div>
                            <h1 className="font-bold text-lg text-slate-700 hidden md:block">MindCanvas</h1>
                            {/* ì €ì¥ ìƒíƒœ í‘œì‹œ */}
                            {user && (
                                <div className="flex items-center text-xs ml-3 px-2 py-1 rounded bg-slate-100">
                                    {saveStatus === 'saving' && <span className="text-orange-500 font-bold">ì €ì¥ ì¤‘...</span>}
                                    {saveStatus === 'saved' && <span className="text-green-600 font-bold">âœ“ ì €ì¥ë¨</span>}
                                    {saveStatus === 'idle' && <span className="text-slate-400">ìµœì‹  ìƒíƒœ</span>}
                                </div>
                            )}
                            {!user && <button onClick={() => window.SBL_MindMap?.login()} className="text-xs bg-indigo-100 text-indigo-700 px-2 py-1 rounded font-bold">ë¡œê·¸ì¸</button>}
                        </div>

                        <div className="flex items-center space-x-1 bg-slate-100 p-1 rounded-lg overflow-x-auto no-scrollbar">
                            <button onClick={addNode} disabled={!selectedId} className={`flex items-center space-x-1 px-3 py-2 rounded-md text-sm font-medium transition-colors whitespace-nowrap ${selectedId ? 'bg-white text-indigo-600 shadow-sm' : 'text-slate-400'}`}><Plus size={18} /><span className="hidden sm:inline">ìì‹ ë…¸ë“œ</span></button>
                            <button onClick={deleteNode} disabled={!selectedId || selectedId === 'root'} className="p-2 text-red-500 rounded-md disabled:text-slate-300"><Trash2 size={20} /></button>
                            <div className="w-px h-6 bg-slate-300 mx-1"></div>
                            <button onClick={cutNode} disabled={!selectedId || selectedId === 'root'} className="p-2 text-slate-700 hover:bg-white rounded-md disabled:text-slate-300"><Scissors size={20} /></button>
                            <button onClick={copyNode} disabled={!selectedId} className="p-2 text-slate-700 hover:bg-white rounded-md disabled:text-slate-300"><Copy size={20} /></button>
                            <button onClick={pasteNode} disabled={!clipboard || !selectedId} className="p-2 text-slate-700 hover:bg-white rounded-md disabled:text-slate-300"><Clipboard size={20} /></button>
                            <div className="w-px h-6 bg-slate-300 mx-1"></div>
                            <button onClick={autoLayout} className="p-2 text-slate-700 hover:bg-white rounded-md"><AlignCenter size={20} /></button>
                        </div>

                        <div className="flex items-center space-x-2">
                            <div className="hidden sm:flex items-center bg-slate-100 rounded-lg p-1">
                                <button onClick={() => setScale(s => Math.max(0.1, s - 0.1))} className="p-1.5 hover:bg-white rounded-md text-slate-600"><Minus size={16} /></button>
                                <span className="w-10 text-center text-xs font-medium text-slate-600">{Math.round(scale * 100)}%</span>
                                <button onClick={() => setScale(s => Math.min(5, s + 0.1))} className="p-1.5 hover:bg-white rounded-md text-slate-600"><Plus size={16} /></button>
                            </div>
                            <button onClick={exportMap} className="p-2 text-slate-600 hover:bg-slate-100 rounded-lg"><Download size={20} /></button>
                            <label className="p-2 text-slate-600 hover:bg-slate-100 rounded-lg cursor-pointer"><Upload size={20} /><input type="file" accept=".json,.opml,.smm" className="hidden" ref={fileInputRef} onChange={importMap} /></label>
                            
                            {/* í™ˆ ë²„íŠ¼ */}
                            <button onClick={() => window.location.href = '../index.html'} className="p-2 text-white bg-slate-700 hover:bg-slate-800 rounded-lg ml-2 shadow-sm flex items-center" title="í™ˆìœ¼ë¡œ"><Home size={20} /></button>
                        </div>
                    </div>

                    <div ref={containerRef} className="flex-1 relative overflow-hidden bg-slate-50 touch-none" onWheel={handleWheel} onMouseDown={(e) => onMouseDown(e, null)} onMouseMove={onMouseMove} onMouseUp={handleEnd} onMouseLeave={handleEnd} onTouchStart={(e) => onTouchStart(e, null)} onTouchMove={onTouchMove} onTouchEnd={handleEnd} style={{ backgroundImage: 'radial-gradient(#cbd5e1 1px, transparent 1px)', backgroundSize: `${20 * scale}px ${20 * scale}px`, backgroundPosition: `${offset.x}px ${offset.y}px` }}>
                        <div className="absolute origin-top-left will-change-transform" style={{ transform: `translate(${offset.x}px, ${offset.y}px) scale(${scale})` }}>
                            <svg className="absolute top-0 left-0 overflow-visible pointer-events-none" style={{ width: 1, height: 1 }}>{renderConnections()}</svg>
                            {nodes.map(node => (
                                <div key={node.id} id={`node-${node.id}`} className={`absolute group flex flex-col items-center justify-center transition-shadow duration-200 touch-none ${selectedId === node.id ? 'ring-2 ring-indigo-500 ring-offset-2 z-10 shadow-lg' : 'shadow-md'}`} style={{ left: node.x, top: node.y, width: node.width, minHeight: '40px', height: 'auto', backgroundColor: node.parentId ? '#ffffff' : '#f0f9ff', borderColor: node.color, borderWidth: node.parentId === null ? 3 : 0, borderLeftWidth: 4, borderRadius: '8px' }} onMouseDown={(e) => onMouseDown(e, node.id)} onTouchStart={(e) => { e.stopPropagation(); onTouchStart(e, node.id); }} onDoubleClick={() => setEditingId(node.id)}>
                                    <div className="w-full h-full px-3 py-2 flex items-center justify-center pointer-events-none">
                                        {editingId === node.id ? (
                                            <textarea autoFocus placeholder="ìƒˆë¡œìš´ í† í”½" className="w-full text-center bg-transparent outline-none border-b border-indigo-300 pointer-events-auto placeholder:text-slate-300 resize-none overflow-hidden" value={node.text} ref={el => { if(el) { el.style.height = 'auto'; el.style.height = el.scrollHeight + 'px'; } }} onInput={(e) => { e.target.style.height = 'auto'; e.target.style.height = e.target.scrollHeight + 'px'; updateNodeText(node.id, e.target.value); }} onBlur={(e) => handleEditBlur(node.id, e.target.value)} onKeyDown={(e) => { if(e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleEditBlur(node.id, e.target.value); } }} />
                                        ) : (
                                            <span className={`text-center w-full select-none break-words whitespace-pre-wrap ${node.parentId === null ? 'font-bold text-lg' : 'text-sm font-medium'}`}>{node.text}</span>
                                        )}
                                    </div>
                                    {selectedId === node.id && ( <div className="absolute bottom-0 right-0 w-6 h-full flex items-center justify-center cursor-ew-resize touch-none p-1 pointer-events-auto hover:bg-black/5 rounded-r-lg" onMouseDown={(e) => onMouseDown(e, node.id, 'resize')} onTouchStart={(e) => { e.stopPropagation(); onTouchStart(e, node.id, 'resize'); }} title="ë„ˆë¹„ ì¡°ì ˆ"><div className="w-1 h-4 bg-slate-300 rounded-full"></div></div> )}
                                </div>
                            ))}
                        </div>
                    </div>
                    
                    <div className="absolute bottom-4 left-4 right-4 sm:right-auto bg-white/90 backdrop-blur p-3 rounded-lg shadow-md text-xs text-slate-500 border border-slate-200 pointer-events-none select-none text-center sm:text-left">
                        <p className="hidden sm:block">ğŸ–±ï¸ ë“œë˜ê·¸: ì´ë™ / íœ : ì¤Œ / ë”ë¸”í´ë¦­: í¸ì§‘ / Ctrl+ë“œë˜ê·¸: ë‹¨ì¼ ì´ë™</p>
                        <p className="sm:hidden">ğŸ‘† í„°ì¹˜: ì´ë™ / ğŸ¤ í•€ì¹˜: ì¤Œ / âœŒï¸ ë”ë¸”íƒ­: í¸ì§‘</p>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
